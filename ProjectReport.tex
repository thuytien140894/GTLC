\documentclass[fleqn, 11pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{dirtytalk}

\title{\bf Implementation of the Simply Typed Lambda Calculus}
\author{Tien Thuy Ho}

\begin{document}
\maketitle

\begin{abstract}
This paper describes the implementation of an interpreter for the simply typed lambda calculus with subtyping using Haskell. The interpreter 
includes a lexer, a parser, a typechecker, an evaluator, and a pretty printer. In order to prevent name collision, variables are represented 
as nameless terms using de Bruijn indices. The substitution operation is thus adjusted to work with nameless terms. The simply typed 
lambda calculus is further extended with records to support subtyping.
\end{abstract}

\section{Introduction}

Lambda calculus is a formal system for mathematical logic developed by Alonzo Church to describe all computation as operations of 
function definition and application [1]. The motivation behind lambda calculus is to provide a simple semantics for computation that allows 
the properties of computation to be easily derived from the core language features, and therefore to be studied formally. In the lambda 
calculus, functions compose every computational expression: the argument accepted by a function is itself a function, and so is the return 
value. Lambda calculus can be used to encode any standard language data and operators: the most prominent example is the encoding of 
natural numbers known as Church numerals using higher-order functions. Such powerful computational expression and syntactical simplicity 
make the lambda calculus a universal language that is the foundation of language study and design. 

The lambda calculus can be untyped or typed. The untyped lambda calculus comprises of three terms: a variable \texttt{x}, an abstraction 
$\lambda \texttt{x.t}$, and an application \texttt{t\textsubscript{1} t\textsubscript{2}}. These terms compose of all computational 
expressions in the lambda calculus, including those that get stuck during evaluation. Therefore, it it important to specify the range of legal inputs and outputs that a function can 
accept and return, respectively, so that meaningless attempts of adding a boolean and a number could be avoided. The simply typed lambda calculus 
introduces two basic types \texttt{Nat} for natural numbers and \texttt{Bool} for booleans. A function specifying an argument type accepts 
all terms that evaluate to values of that type. Similarly, a function specifying a return type is guaranteed to return values of that type 
only. Imposing constraints on the function domain and range using types makes the function behavior more well-defined and less unpreditable 
when operating with arbitrary user inputs.

While the lambda calculus is mostly used as a formal system for language study, it it equally important to see how its formal definitions are 
implemented as the actual facilities of a programming language. For this project, we constructed an interpreter for the simply typed 
lambda calculus with subtyping using Haskell. The interpreter consists of a lexical analyzer to tokenize a stream of characters, a parser to build an 
abstract tree syntax out of the tokens, a typechecker to verify the type safety of the source program, an evaluator to produce a result for 
the program, and a pretty printer to output the evaluation result in a user-readable format. 

\section{Formal Definitions}

In this section, we will cover the formal definitions of the syntax, typing rules, subtype relation, and evaluation rules for our 
lambda calculus.

\subsection{Syntax}

The syntax of our simply typed lambda calculus combines both the untyped lambda calculus and arithmetic expressions, as 
well as records. Following are the definitions for terms, values, and numeric values [1].

\begin{align*}
    \texttt{t} \hspace{2mm} ::= \hspace{2mm} &\texttt{x} \\
                                             &\lambda \texttt{x:T} . \hspace{1mm} \texttt{t} \\
                                             &\texttt{t} \hspace{1mm} \texttt{t} \\
                                             &\texttt{succ t} \\
                                             &\texttt{pred t} \\
                                             &\texttt{iszero t} \\
                                             &\{\texttt{l\textsubscript{i}=t\textsubscript{i}}^{i \in 1..n}\} \\
                                             &\texttt{t.l} \\
                                             &\texttt{if t t t} \\ \\
    \texttt{v} \hspace{2mm} ::= \hspace{2mm} &\texttt{unit} \\
                                             &\texttt{0} \\
                                             &\texttt{true} \\
                                             &\texttt{false} \\
                                             &\texttt{nv} \\
                                             &\{\texttt{l\textsubscript{i}=v\textsubscript{i}}^{i \in 1..n}\} \\
                                             &\lambda \texttt{x:T} . \hspace{1mm} \texttt{t} \\ \\
    \texttt{nv} \hspace{2mm} ::= \hspace{2mm} &\texttt{0} \\
                                             &\texttt{succ nv} \\
\end{align*}

We include value \texttt{unit} as part of the syntax for the purpose of parsing applications, which will be discussed later in the 
implementation of a parser.

\subsection{Typing Rules}

Types in our simply typed lambda calculus include the base types \texttt{Nat} and \texttt{Bool}, function types that map the argument type to 
the return type, and record types. In addition, type \texttt{Top} is added as the supertype of all the type [1].

\begin{align*}
    \texttt{T} \hspace{2mm} ::= \hspace{2mm} &\texttt{Top} \\
                                             &\texttt{Unit} \\
                                             &\texttt{Bool} \\
                                             &\texttt{Nat} \\
                                             &\texttt{T} \rightarrow \texttt{T} \\
                                             &\{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\} 
\end{align*}

In this project, the base type \texttt{Unit} is used to parse function types as well as to represent free variables with no bound types.  
Again, we will discuss the use of \texttt{Unit} in more detail later when we describe the parsing process. Given the type system above, 
the typing rules for our language are defined as follows [1]:

\begin{enumerate}
    \item \textbf{Numbers}
    \begin{itemize}
        \item \texttt{T-ZERO} : if $\Gamma \vdash \texttt{0} : \texttt{R}$, then $\texttt{R} = \texttt{Nat}$
        \item \texttt{T-SUCC} : if $\Gamma \vdash \texttt{succ t\textsubscript{1}} : \texttt{R}$, 
        then $\texttt{R} = \texttt{Nat}$ and $\texttt{t\textsubscript{1}} = \texttt{Nat}$
        \item \texttt{T-PRED} : if $\Gamma \vdash \texttt{pred t\textsubscript{1}} : \texttt{R}$, 
        then $\texttt{R} = \texttt{Nat}$ and $\texttt{t\textsubscript{1}} = \texttt{Nat}$
        \item \texttt{T-ISZERO} : if $\Gamma \vdash \texttt{succ t\textsubscript{1}} : \texttt{R}$, 
        then $\texttt{R} = \texttt{Bool}$ and $\texttt{t\textsubscript{1}} = \texttt{Nat}$
    \end{itemize}

    \item \textbf{Booleans}
    \begin{itemize}
        \item \texttt{T-TRUE} : if $\Gamma \vdash \texttt{true} : \texttt{R}$, then $\texttt{R} = \texttt{Bool}$
        \item \texttt{T-FALSE} : if $\Gamma \vdash \texttt{false} : \texttt{R}$, then $\texttt{R} = \texttt{Bool}$
        \item \texttt{T-IF} : if $\Gamma \vdash \texttt{if t\textsubscript{1} then t\textsubscript{2} else t\textsubscript{3}} 
        : \texttt{R}$, then $\Gamma \vdash \texttt{t\textsubscript{1}} : \texttt{Bool}$ and 
        $\Gamma \vdash \texttt{t\textsubscript{2},t\textsubscript{3}}  : \texttt{R}$
    \end{itemize}

    \item \textbf{Lambda Calculus}
    \begin{itemize}
        \item \texttt{T-VAR} : if $\Gamma \vdash \texttt{x} : \texttt{R}$, then $\texttt{x:R} \in \Gamma$.
        \item \texttt{T-ABS} : if $\Gamma \vdash \lambda \texttt{x:T\textsubscript{1}.t\textsubscript{2}} : \texttt{R}$, 
        then $\texttt{R} = \texttt{T\textsubscript{1}} \rightarrow \texttt{T\textsubscript{2}}$ for some \texttt{T\textsubscript{2}} 
        with $\Gamma, \texttt{x:T\textsubscript{1}} \vdash \texttt{t\textsubscript{2}} : \texttt{T\textsubscript{2}}$
        \item \texttt{T-APP} : if $\Gamma \vdash \texttt{t\textsubscript{1} t\textsubscript{2}} : \texttt{R}$, then there 
        is some type \texttt{T\textsubscript{11}} such that 
        $\Gamma \vdash \texttt{t\textsubscript{1}} : \texttt{T\textsubscript{11}} \rightarrow \texttt{R}$ and 
        $\Gamma \vdash \texttt{t\textsubscript{2}} : \texttt{T\textsubscript{11}}$
    \end{itemize}

    \item \textbf{Records}
    \begin{itemize}
        \item \texttt{T-RCD} : if $\Gamma \vdash \{\texttt{l\textsubscript{i}=t\textsubscript{i}}^{i \in 1..n}\} : 
        \{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\}$, then 
        $\Gamma \vdash \texttt{t\textsubscript{i}} : \texttt{T\textsubscript{i}}$ for each \texttt{i}
        \item \texttt{T-PROJ} : if $\Gamma \vdash \texttt{t\textsubscript{1}.l\textsubscript{j}} : \texttt{T\textsubscript{j}}$, 
        then $\Gamma \vdash \texttt{t\textsubscript{1}} : \{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\}$ and 
        $\texttt{j} \in 1..n$
    \end{itemize}

    \item \textbf{Subtype}
    \begin{itemize}
        \item \texttt{T-SUB} : if $\Gamma \vdash \texttt{t} : \texttt{S}$ and $\texttt{S} <: \texttt{T}$ for some type \texttt{T}, then 
        $\Gamma \vdash \texttt{t} : \texttt{T}$
    \end{itemize}
\end{enumerate}

\subsection{Subtype Relation}

The subtype relation between two types is determined using the following rules [1]:

\begin{enumerate}
    \item \textbf{Lambda Calculus}
    \begin{itemize}
        \item \texttt{S-REFL} : $\texttt{S} <: \texttt{S}$ 
        \item \texttt{S-TOP} : $\texttt{S} <: \texttt{Top}$ 
        \item \texttt{S-ARROW} : if $\texttt{T\textsubscript{1}} <: \texttt{S\textsubscript{1}}$ and 
        $\texttt{S\textsubscript{2}} <: \texttt{T\textsubscript{2}}$, then 
        $\texttt{S\textsubscript{1}} \rightarrow \texttt{S\textsubscript{2}} <: \texttt{T\textsubscript{1}} \rightarrow \texttt{T\textsubscript{2}}$
    \end{itemize}

    \item \textbf{Records}
    \begin{itemize}
        \item \texttt{S-RCDWIDTH} : $\{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n+k}\} 
        <: \{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\}$
        \item \texttt{S-RCDDEPTH} : if $\{\texttt{l\textsubscript{i}:S\textsubscript{i}}^{i \in 1..n}\} 
        <: \{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\}$, then 
        $\texttt{S\textsubscript{i}} <: \texttt{T\textsubscript{i}}$ for each \texttt{i} 
        \item \texttt{S-RCDPERM} : if $\{\texttt{k\textsubscript{j}:S\textsubscript{j}}^{j \in 1..n}\}$ 
        is a permutation of $\{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\}$, then 
        $\{\texttt{k\textsubscript{j}:S\textsubscript{j}}^{j \in 1..n}\} <: \{\texttt{l\textsubscript{i}:T\textsubscript{i}}^{i \in 1..n}\}$
    \end{itemize}
\end{enumerate}

\texttt{S-TRANS} is not included because it cannot be transliterated directly in our implementation. \texttt{S-TRANS} is used more as a 
tool for formal subtyping derivation. The combination of \texttt{S-RCDWIDTH}, \texttt{S-RCDDEPTH}, and \texttt{S-RCDPERM} suffices to 
account for the implication of \texttt{S-TRANS}. For example, given 
$\texttt{r\textsubscript{1}} = \{\texttt{x:\{a:Nat,b:Nat\},y:\{m:Nat\}\}}$ and 
$\texttt{r\textsubscript{2}} = \{\texttt{x:\{a:Nat\}\}}$. Instead of finding \texttt{u} to satisfy the transitive relation 
$\texttt{r\textsubscript{1}} <: \texttt{u}$ and $ \texttt{u} <: \texttt{r\textsubscript{1}}$, we can 
directly assert that $\texttt{r\textsubscript{1}} <: \texttt{r\textsubscript{2}}$ because (1) \texttt{r\textsubscript{1}} has more fields 
than \texttt{r\textsubscript{2}} by \texttt{S-RCDWIDTH}, and (2) the common field \texttt{x} in \texttt{r\textsubscript{1}} has type \texttt{\{a:Nat,b:Nat\}},  
which is a subtype of \texttt{\{a:Nat\}} in \texttt{r\textsubscript{2}} according to \texttt{S-RCDDEPTH}.

\subsection{Evaluation Rules}

The following are the evaluation rules for the lambda calculus [1]:

\begin{enumerate}
    \item \textbf{Arithmetic Expressions}
    \begin{itemize}
        \item \texttt{E-PREDZERO} : $\texttt{pred 0} \rightarrow \texttt{0}$ 
        \item \texttt{E-PREDSUCC} : $\texttt{pred (succ nv)} \rightarrow \texttt{nv}$ 
        \item \texttt{E-ISZEROZERO} : $\texttt{iszero 0} \rightarrow \texttt{true}$ 
        \item \texttt{E-ISZEROSUCC} : $\texttt{iszero (succ nv)} \rightarrow \texttt{false}$ 
        \item \texttt{E-SUCC} : if $\texttt{t} \rightarrow \texttt{t'}$, then $\texttt{succ t} \rightarrow \texttt{succ t'}$
        \item \texttt{E-PRED} : if $\texttt{t} \rightarrow \texttt{t'}$, then $\texttt{pred t} \rightarrow \texttt{pred t'}$
    \end{itemize}

    \item \textbf{Conditionals}
    \begin{itemize}
        \item \texttt{E-IFTRUE} : $\texttt{if true then t\textsubscript{2} else t\textsubscript{3}} \rightarrow \texttt{t\textsubscript{2}}$
        \item \texttt{E-IFFALSE} : $\texttt{if false then t\textsubscript{2} else t\textsubscript{3}} \rightarrow \texttt{t\textsubscript{3}}$
        \item \texttt{E-IF} : if $\texttt{t\textsubscript{1}} \rightarrow \texttt{t\textsubscript{1}'}$, 
        then $\texttt{if t\textsubscript{1} then t\textsubscript{2} else t\textsubscript{3}} \rightarrow 
        \texttt{if t\textsubscript{1}' then t\textsubscript{2} else t\textsubscript{3}}$,
    \end{itemize}

    \item \textbf{Records}
    \begin{itemize}
        \item \texttt{E-PROJRCD} : $\{\texttt{l\textsubscript{i}=v\textsubscript{i}}^{i \in 1..n}\}.\texttt{l\textsubscript{j}} 
        \rightarrow $\texttt{v\textsubscript{j}}
        \item \texttt{E-PROJ} : if $\texttt{t} \rightarrow \texttt{t'}$, then 
        $\texttt{t.l} \rightarrow \texttt{t'.l}$
        \item \texttt{E-RCD} : if $\texttt{t\textsubscript{j}} \rightarrow \texttt{t\textsubscript{j}'}$, then \\
        $\{\texttt{l\textsubscript{i}:v\textsubscript{i}}^{i \in 1..j-1},\texttt{l\textsubscript{j}:t\textsubscript{j}}, 
        \texttt{l\textsubscript{k}:v\textsubscript{k}}^{k \in j+1..n}\} \rightarrow 
        \{\texttt{l\textsubscript{i}:v\textsubscript{i}}^{i \in 1..j-1},\texttt{l\textsubscript{j}:t\textsubscript{j}'}, 
        \texttt{l\textsubscript{k}:v\textsubscript{k}}^{k \in j+1..n}\}$ 
    \end{itemize}

    \item \textbf{Application}
    \begin{itemize}
        \item \texttt{E-APPABS} : $(\lambda \texttt{x:T\textsubscript{11}.t\textsubscript{12}})\texttt{v\textsubscript{2}} \rightarrow 
        [\texttt{x} \rightarrow \texttt{v\textsubscript{2}}]\texttt{t\textsubscript{12}}$
        \item \texttt{E-APP2} : if $\texttt{t\textsubscript{2}} \rightarrow \texttt{t\textsubscript{2}'}$, then 
        $\texttt{v\textsubscript{1} t\textsubscript{2}} \rightarrow \texttt{v\textsubscript{1} t\textsubscript{2}'}$
        \item \texttt{E-APP1} : if $\texttt{t\textsubscript{1}} \rightarrow \texttt{t\textsubscript{1}'}$, then 
        $\texttt{t\textsubscript{1} t\textsubscript{2}} \rightarrow \texttt{t\textsubscript{1}' t\textsubscript{2}}$
    \end{itemize}
\end{enumerate}

\section{Related Work}

This project is modeled after an OCaml implementation of the simply typed lambda calculus described in \textit{Types and Programming 
Languages} by Benjamin C. Pierce. In order to faciliate the implementation process, the author suggests using languages that support 
automatic memory management and pattern matching for easily defining recursive functions [1]. Therefore, Haskell is a suitable candidate 
for this implementation. 

The OCaml implementation represents variables as nameless terms using de Bruijn indices, and as a result defines its own substitution procedure. 
Before we go into explaining the mechanism behind nameless representation of terms, it is necessary to understand potential problems 
arising from working directly with variable names during the operation of substitution.

\subsection{Variable Capture}

Variable capture describes a situation in which free variables become bound after substitution [1]. For example:

\[
    [x \rightarrow y](\lambda y . \hspace{1mm} x) = \lambda y . \hspace{1mm} y
\]

In this case, the free variable $y$ is bound after being substituted into $\lambda y.x$, resulting in an identity function and 
contradicting with the original function definition. One solution to avoid variable capture is to rename bound variables so that they 
differ from free variables of the same name. In the example above, we can rewrite $\lambda y.x$ as $\lambda z.x$ as follows:

\[
    [x \rightarrow y](\lambda z . \hspace{1mm} x) = \lambda z . \hspace{1mm} y
\]

However, this renaming approach can become tedious for our purpose of implementation since we would have to keep checking for name 
collision and coming up with new names, which could then conflict with new variables introduced later. Instead, the OCaml implementation 
uses de Bruijn indices to represent variables, without the necessity of renaming. 

\subsection{Nameless Representation of Terms}

De Bruijn indices replace named variables with numbers to directly indicate their respective binders from right to left [1]. For example, 
$\lambda x . \lambda y \hspace{1mm} x \hspace{1mm} (y \hspace{1mm} x)$ is rewritten as $\lambda . \lambda \hspace{1mm} 1 \hspace{1mm} (0 \hspace{1mm} 1)$. 
That is, $y$ is bound by the first binder and $x$ by the second. On the other hand, since free variables have no binders, their indices are 
determined using a naming context that maps their names to some pre-defined numbers. Continuing with the last example, if we introduce 
$z$ as a free variable and $z \rightarrow 2$ in the naming context, then 
$\lambda x . \lambda y . \hspace{1mm} x \hspace{1mm} (y \hspace{1mm} x \hspace{1mm} z)$ is equivalent to 
$\lambda . \lambda . \hspace{1mm} 1 \hspace{1mm} (0 \hspace{1mm} 1 \hspace{1mm} 4)$. The index of $z$ is incremented by two to correspond 
to the number of binders within which $z$ is included.

\subsection{Shifting and Substitution}

Using de Bruijn indices to identify variables, the substitution operation requires a subroutine to renumber the indices of free variables 
in a term. For example, suppose we have a substitution $[x\rightarrow s](\lambda z. \hspace{1mm} x)$, 
which is namelessly represented as $[0\rightarrow s](\lambda . \hspace{1mm} 1)$, where all the x occurences in $t = \lambda z . \hspace{1mm} x$ 
are replaced with $s$. For every binder that a variable is nested, its index is incremented by 1. Therefore, index 1 under the $\lambda$-
abstraction and index 0 in the outer context refer to the same variable, that is $x$. When replacing $x$ with $s$, all the free variables 
in $s$ would have to be incremented by 1 as well because they are now under the $\lambda$-abstraction. However, the described shifting 
operation is only applied to free variables. If $s$ contains a binder, as in $s = (\lambda y . \hspace{1mm} y) \hspace{1mm} h$, then 
the index for $h$ is shifted up by 1, but not the index for $y$ because it is bound. Given that $y \rightarrow 0$ under the definition of 
nameless representation of terms, shifting $y$ would unbind $y$ from its $\lambda$-abstraction, consequently invalidating $s$.

To limit the scope of shifting, we maintain a threshold parameter $c$ that distinguishes free variables from bound variables. We initialize $c$ to 
0 and then increment it every time it passes a binder. When a term $t$ is to be shifted, $c$ indicates the number of binders within which $t$  
is nested. Therefore, any variable with an index $k < c$ is obviously bound to one of the $\lambda$-abstractions; on the other hand, 
variables with indices $k \geq c$ are free and therefore should be shifted. Continuing with the previous example of $s = (\lambda y . \hspace{1mm} y) \hspace{1mm} h$, 
that is, $s = (\lambda . \hspace{1mm} 0) \hspace{1mm} 1$, while $h$ is shifted because its index $1 > c = 0$, $y$ remains the same because 
its index $0 < 1 = c$. The definition for shifting is defined as follows [1]:

\begin{align*}
&\uparrow _c^d(k) \hspace{6mm}= 
    \begin{cases}   
        k & \text{if $k<c$} \\
        k + d & \text{if $k \geq c$} \\
    \end{cases} \\
&\uparrow _c^d(\lambda . \hspace{1mm} t_1) = \lambda . \hspace{1mm} \uparrow _{c+1}^d (t_1) \\
&\uparrow _c^d(t_1 \hspace{1mm} t_2) = \hspace{1mm} \uparrow _c^d(t_1) \hspace{1mm} \uparrow _c^d(t_2)
\end{align*} \\

\noindent
where $c$ is the threshold number, $d$ is the shifting offset, and $k$ is the variable index. As a result, the substitution 
procedure $[j \rightarrow s]t$ is defined as:

\begin{align*}
    &[j \rightarrow s]k \hspace{6mm}= 
        \begin{cases}   
            s & \text{if $k=j$} \\
            k & \text{otherwise} \\
        \end{cases} \\
    &[j \rightarrow s](\lambda . \hspace{1mm} t_1) = \lambda . \hspace{1mm} [j + 1 \rightarrow \uparrow^1 (s)]t_1 \\
    &[j \rightarrow s](t_1 \hspace{1mm} t_2) = \hspace{1mm} [j \rightarrow s]t_1 \hspace{1mm} [j \rightarrow s]t_2
\end{align*} \\

\noindent
where $s$ is the term being substituted for the bound variable, and $j$ is the variable index.

\section{Implementation}

\subsection{Language Specification}

We structure our implementation after the formal definitions discussed in section 2.

\subsubsection{Syntax}

Using the data mechanism of Haskell [2], we first define values for a new type \texttt{Term} used for constructing abstract syntax trees 
during the parsing phase. \texttt{Term} follows the formal syntax of the lambda calculus described in section 2.1.

\begin{Verbatim}
    data Term 
        = Unit                                                      
        | Zero                                                       
        | Tru                                                       
        | Fls                                                         
        | Var {index :: Int, ty :: Type, name :: String}             
        | If Term Term Term                                          
        | Succ Term                                                 
        | Pred Term                                                  
        | IsZero Term                                                
        | Rec [(String, Type)]                                       
        | Proj Term String                                            
        | Lambda {varTy :: Type, body :: Term, boundVars :: [String]}
        | App Term Term                                              
\end{Verbatim}

The representation of a variable consists of a de Bruijn index, a type, a name string. Instead of maintaining a global type environment 
$\Gamma$ as in the OCaml implementation, we have a variable remember its own bound type. Bound variables will have types of either 
\texttt{Bool}, \texttt{Nat}, a function type, or a record type. On the other hand, free variables will have type \texttt{TUnit}.
When our parser encounters an identifier, it will produce a free variable by initializing its type to \texttt{TUnit}. The variable 
type will be then updated as its binder is introduced. In addition to type, each variable is also supplemented with its original name 
for the purpose of printing back to the user. 

A $\lambda$-abstraction is represented with an extra list of bound variables. For example, $s = \lambda y:Nat . \hspace{1mm} y$ has 
[$y$] as its bound variables. If we add another $\lambda$-abstraction inside $s$, as in 
$s = \lambda y:Nat . \hspace{1mm} \lambda x:Nat . \hspace{1mm} x \hspace{1mm} y$, then the list of bound variables for $y$-
abstraction is [$y$,$x$]; $x$-abstraction, on the other hand, only has [$x$] as the bound variables because $y$ is free 
in its context. This list of bound variables is used primarily for numbering a variable with its correct de Bruijn index, by finding the 
index of the variable name from the end of the list. $x$ is mapped to 0 because it is bound to the most right $\lambda$-abstraction and 
$y$ is mapped to 1.

A record is represented as a list of binary tuples mapping a label to its term. For convenience, we use \texttt{Entry} to refer to 
a mapping between label and its term in our implementation. A projection is defined as a constructor function that 
takes in a term and a label.

\subsubsection{Type System}

In the same way that we define data type \texttt{Term} for the syntax, the type system is defined using a new data type, \texttt{Type}.

\begin{Verbatim}
    data Type 
        = TUnit                  
        | Top                    
        | Bool                   
        | Nat                    
        | Arr Type Type          
        | TRec [(String, Type)]                                            
\end{Verbatim}

A function type is represented as a constructor function that takes an argument type and a return type. A record type \texttt{TRec} is a list
of binary tuples mapping a label to the type of its associated term. For convenience, a tuple (label, type) is defined as \texttt{TEntry} 
for the rest of our implementation. 

\subsection{Parsing}

Now that we have defined the syntax and type system for the lambda calculus, we use Haskell parser library, Parsec [5], to implement (1) a lexer 
to tokenize the user input, and (2) a parser to create abstract syntax trees.

\subsubsection{Lexer}

We first create the language definition to specify how each individual characters are tokenized, as follows:

\begin{Verbatim}
    langDef :: Tok.LanguageDef ()
    langDef = Tok.LanguageDef
        { Tok.commentStart    = "" 
        , Tok.commentEnd      = ""
        , Tok.commentLine     = "//"
        , Tok.nestedComments  = False
        , Tok.identStart      = letter 
        , Tok.identLetter     = alphaNum 
        , Tok.opStart         = oneOf ":!#$%&*+./<=>?@\\^|-~"
        , Tok.opLetter        = oneOf ":!#$%&*+./<=>?@\\^|-~"
        , Tok.reservedNames   = [ "true"
                                , "false"
                                , "if"
                                , "then"
                                , "else"
                                , "succ"
                                , "pred"
                                , "iszero"
                                , "zero"
                                , "Bool"
                                , "Nat" ]
        , Tok.reservedOpNames = [ "succ"
                                , "pred"
                                , "iszero" ]
        , Tok.caseSensitive   = True
        }
\end{Verbatim}

Our lambda calculus does not support block comments or nested comments, requires that identifiers start with a letter and end with 
alphanumeric characters. We also reserve some keywords that cannot be used by the identifiers. The lexer then defines a number of 
lexical parsers to parse identifiers, expressions inside parentheses, reserved words and operations, etc.

\subsubsection{Parser}

Given the tokens provided by the lexer, the parser uses our syntax and type system to generate valid expressions and build abstract 
syntax trees. Eight types of expressions that need to be parsed are boolean and numeric constants (\texttt{true}, \texttt{false}, \texttt{0}), 
variables, $\lambda$-abstraction, conditional (\texttt{if} statement), arithmetic (\texttt{succ}, \texttt{pred}, \texttt{iszero}), 
projection, record, and any expression enclosed in parentheses, as described below:

\begin{Verbatim}    
    expr' :: Parser Term
    expr' = parenExpr
        <|> true
        <|> false
        <|> zero
        <|> var
        <|> lambda
        <|> conditional
        <|> arith
        <|> try projection 
        <|> record
\end{Verbatim}

Here we use the combinator \texttt{<|>} to create a sequence of parser options. If the parser \texttt{true} fails without consuming 
any input, then the parser \texttt{false} will be used next [4]. When there is a common prefix between two chained parsers, we use 
the combinator \texttt{try} to be able to use the second parser even if the first parser fails and consumes some input. Accordingly, 
since a projection and a record expression both start with a record, \texttt{try projection <|> record} has the parser first try to parse 
an expression as a projection, and then as a record if the expression does not have a \texttt{.} operator and a label that follow a record 
term.

As mentioned before, all variables are parsed as free initially by making its type \texttt{TUnit}.

\begin{Verbatim}
    var :: Parser Term
    var = do
        id <- identifier
        return $ Var (-1) TUnit id          
\end{Verbatim}

We also initialize the de Bruijn index of a new variable to -1 because its context is not known until its $\lambda$-abstraction 
is parsed later.

\begin{Verbatim}
    lambda :: Parser Term
    lambda = do 
        lamb >> whiteSpace
        arg <- identifier 
        colon >> whiteSpace
        ty <- types
        dot >> whiteSpace
        body <- expr
        let boundVars = arg : getBoundVar body
        let freeVars = getFreeVar body boundVars 
        let t = fixBinding (Lambda ty body boundVars) boundVars freeVars
        return $ updateVarType t arg ty         
\end{Verbatim}

The parser for $\lambda$-abstraction is responsible for generate the list of bound variables found inside an abstraction,
and renumbering free and bound variables using the subroutine \texttt{fixBinding}. Instead of maintaining a 
global naming context that maps free variables to pre-defined indices as described in section 3.2, we first record 
all the free variables in a list \texttt{freeVars}: the index of a free variable is its index in \texttt{freeVars} plus 
the total number of bound variables. This addition ensures that a free index is always greater than or equal to 
the number of binders in an abstraction, and therefore does not conflict with bound indices. Finally, we propagate the bound 
type to all the variables that bind to the parsed abstraction. These variables will no longer have type \texttt{TUnit}, and 
thus become bound.

At the top level, the parser parses an expression as an application that consists of terms defined in the parser \texttt{expr'}. 
All the parsed expressions separated by a white space are recursively applied from left to right to reflect the left-associativity 
of terms. We use the higher-order library function \texttt{foldl} to perform this pattern of recursion.

\begin{Verbatim}
    applyFromLeft :: [Term] -> Term
    applyFromLeft = foldl apply Unit
\end{Verbatim}

\texttt{foldl} takes in a binary operator \texttt{apply} and an accumulator \texttt{Unit}. \texttt{Unit} here is treated as the 
application identity, that is, applying \texttt{Unit} to a term returns the term itself. In other words, the function \texttt{applyFromLeft} 
when called on a list of expressions applies the first expression to \texttt{Unit}, and returns the same expression as the next 
accumulator. This same technique is used when parsing function types given \texttt{TUnit} as the identity. One significant difference is 
that types associate to the right; as a result, \texttt{foldr} is used instead of \texttt{foldl}.

\begin{Verbatim}
    arrowFromRight :: [Type] -> Type
    arrowFromRight = foldr arrow TUnit
\end{Verbatim}

\subsubsection{Typechecker}

Before a term is evaluated, it needs to be typechecked to minimize the number of senseless evaluations and thus ensure the safety of a 
program. The typechecking function \texttt{typeOf} requires that every syntactical form meets certain conditions to be well-typed. 
We use the monad \texttt{Either TypeError Type} to allow two possible return results for \texttt{typeOf}: a type error or a type. 
\texttt{typeOf} returns a type error in a \texttt{Left} constructor and a type in a \texttt{Right} constructor. First of all, constants 
like \texttt{true/false} and \texttt{0} automatically have the type \texttt{Bool} (\texttt{T-TRUE/T-FALSE}) and \texttt{Nat} (\texttt{T-ZERO}), 
respectively. Typechecking other expressions will throw an error if they fail to meet their type conditions. Type errors are defined as:

\begin{Verbatim}
    data TypeError 
        = NotBound Term 
        | NotBool Type
        | NotNat Type
        | NotFunction Term
        | NotRecord Term
        | Difference Type Type
        | Mismatch Type Type
        | InvalidLabel String 
        | IllTyped
\end{Verbatim}

A \texttt{NotBound} error occurs when a variable has type \texttt{TUnit} and therefore is not bound. If a variable has a bound type other 
than \texttt{TUnit}, then this type is returned. \texttt{case} expressions are used extensively in the function 
\texttt{typeOf} for pattern matching. The wild card \texttt{\char`_} is used to match any pattern.

% T-VAR
\begin{Verbatim}
    -- T-VAR
    Var _ ty id     -> case ty of                           
        TUnit -> Left $ NotBound t   
        _     -> Right ty
\end{Verbatim}

A \texttt{NotBool} error is primarily used for typechecking the condition in an if-else statement. Conditionals must have a boolean condition.

% T-IF
\begin{Verbatim}
    -- T-IF
    If t1 t2 t3     -> do                                       
        cond <- typeOf t1 
        fst  <- typeOf t2 
        snd  <- typeOf t3 
        case cond of 
            Bool | fst == snd -> Right fst 
                 | otherwise  -> Left $ Difference fst snd
            _    -> Left $ NotBool t cond           
\end{Verbatim}

Even if a conditional has a boolean condition, another potential type error that can happen to a conditional is \texttt{Difference} in which 
the types of the two conditional branches are not the same. If both typing requirements for the condition and the branches of a conditional 
are satisfied, the type of one of the branches is returned.

When an arithmetic expression does not have a numeric argument, then a \texttt{NotNat} error is thrown. 

% T-SUCC
\begin{Verbatim}
    -- T-SUCC
    Succ t'         -> do                                     
        ty <- typeOf t' 
        case ty of  
            Nat -> Right Nat
            _   -> Left $ NotNat ty          
\end{Verbatim}

% T-PRED
\begin{Verbatim}
    -- T-PRED
    Pred t'         -> do                                     
        ty <- typeOf t' 
        case ty of  
            Nat -> Right Nat
            _   -> Left $ NotNat ty          
\end{Verbatim}

% T-ISZERO
\begin{Verbatim}
    -- T-ISZERO
    IsZero t'       -> do                                      
        ty <- typeOf t' 
        case ty of 
            Nat  -> Right Bool
            _    -> Left $ NotBool t ty            
\end{Verbatim}

Else, \texttt{succ t} and \texttt{pred t} have type \texttt{Nat}, whereas \texttt{iszero t} has type \texttt{Bool}. In addition to the 
base types \texttt{Bool} and \texttt{Nat}, function types \texttt{T\textsubscript{1}} $\rightarrow$ \texttt{T\textsubscript{2}} are 
returned for a $\lambda$-abstraction by mapping the type of its bound variable to the type of its body term.  

% T-ABS
\begin{Verbatim}
    -- T-ABS
    Lambda ty t' _   -> Arr ty <$> typeOf t'    
\end{Verbatim}

Any type error resulted from typechecking the body term of a $\lambda$-abstraction will be immediately thrown. One notable feature to 
operate with monads is the applicative function \texttt{<\$>}, which applies a monad value to a function expecting a normal value. 
Accordingly, \texttt{Arr ty <\$> typeOf t'} takes the monad value returned from typechecking \texttt{t'}, and then applies it as the 
second argument for the constructor function \texttt{Arr}.

Typechecking a record typechecks each term in the record. If the first term has a valid type, then we recursively typecheck the tail 
of the record list until it is empty. The subroutine \texttt{addType} creates the record type \texttt{TRec} by combining all the 
field types.  

% T-RCD
\begin{Verbatim}
    -- T-RCD
    rcdTypeOf (Rec [])                = Right $ TRec []
    rcdTypeOf (Rec ((l1, t1) : ys))   = case typeOf t1 of 
        Right ty   -> (`addType` (l1, ty)) <$> rcdTypeOf (Rec ys) 
        Left err   -> Left err
\end{Verbatim}

A legal projection \texttt{t.l} requires \texttt{t} to be a record and \texttt{l} to be the label of one of the record fields. The type 
of the matched field is returned as the projection type.

% T-PROJ
\begin{Verbatim}
    -- T-PROJ
    Proj t l   -> case t of                                
        Rec ls -> case typeOf (Rec ls) of                       
                    Right ty -> getType ty l
                    Left err -> Left err
        _      -> Left $ NotRecord t 
\end{Verbatim}

If the term \texttt{t} is not a record, then a \texttt{NotRecord} error is thrown. Else, if the record \texttt{t} does not contain the input 
label \texttt{l}, a \texttt{InvalidLabel} error is thrown. The final case of typechecking is application. According to \texttt{T-APP}, the first 
term \texttt{t\textsubscript{1}} of an application needs to have a function type \texttt{Arr argTy retTy}, or throws a \texttt{NotFunction} 
error. Another type error an application can encounter is \texttt{Mismatch} in which the argument type and the type expected by the function 
are different. 

% T-APP
\begin{Verbatim}
    -- T-APP + T-SUB
    App t1 t2       -> do                                            
        funcTy  <- typeOf t1   
        argTy <- typeOf t2                         
        case funcTy of 
            Arr paramTy retTy 
                | argTy `isSubtype` paramTy -> Right retTy
                | otherwise                 -> Left $ Mismatch argTy paramTy
            _                               -> Left $ NotFunction t1
\end{Verbatim}

Instead of checking for equality between the argument type and the parameter type, we perform a subtyping check between them. According to  
\texttt{T-SUB}, if the argument type \texttt{argTy} is the subtype of the parameter type \texttt{paramTy}, then \texttt{argTy} is equivalent to 
\texttt{paramTy}, and thus can be accepted by the function.  

\subsubsection{Subtyping}

The basic subtype relation consists of three inference rules (\texttt{S-TOP}, \texttt{S-REFL}, \texttt{S-ARROW}), which are 
described in section 2.3 and translated as:

\begin{Verbatim}
    isSubtype _ Top                    = True                                      
    isSubtype s t | s == t             = True                                     
    isSubtype (Arr s1 s2) (Arr t1 t2)  = t1 `isSubtype` s1 && s2 `isSubtype` t2 
\end{Verbatim}

Here we only define the subtype relation at an abstract level in which two types in question are semantically related in some 
way, through reflexion and function mapping. With an exception of \texttt{Top} being the maximum element of the subtype hierarchy, we 
need a way to be able to directly determine the subtype relation between two non-function types. Unlike nominal type systems in 
which subtyping is explicitly declared [2], we primarily rely on the record structure for subtyping.

\begin{Verbatim}
    isSubtype (TRec s) (TRec t)        = s `isRcdSubtype` t
\end{Verbatim}

Accordingly, the subtype relation between record types \texttt{S} and \texttt{T} is dictated by three following rules:

\begin{itemize}
    \item \texttt{S-RCDWIDTH}  : a record type with fewer fields is a supertype, given common fields.
    \item \texttt{S-RCDDEPTH} : a record type whose fields are the supertypes is a supertype.
    \item \texttt{S-RCDPERM} : record types with common fields regardless of their order are equivalent.
\end{itemize}

Each rule, nonetheless, cannot operate on its own. A record type with fewer but uncommon fields cannot be immediately rejected for 
subtyping using \texttt{S-RCDWIDTH}, because these fields might be the supertypes of those in the second record type according to  
\texttt{S-RCDDEPTH}. Also, in order to check for the subtype relation between fields of two record types, we cannot assume that 
their positions align because the field order does not matter, as stated in \texttt{S-RCDPERM}. The subroutine 
\texttt{isRcdSubtype} to determine the subtype relation between two record types combines all three rules instead of 
making \texttt{case} expressions for each rule. 

\begin{Verbatim}
    isRcdSubtype :: [TEntry] -> [TEntry] -> Bool
    isRcdSubtype s t 
        | widthS >= widthT  = sortedS `isSubset` sortedT
        | otherwise         = False
        where (widthS, widthT)   = (length s, length t)
              (sortedS, sortedT) = (sortFields s, sortFields t)
\end{Verbatim}

Under the assumption that the first argument is supposed to be a subtype of the second one, we first check the lengths of the two 
record lists. If the second record list is longer, \texttt{S-RCDWIDTH} is violated, and subtyping immediately fails as a result. 
Otherwise, we sort both record lists alphabetically by their labels so that common fields of the two lists, if there are any, align. 
This sorting mechanism accounts for the fact that two lists might be permutations of each other.

\begin{Verbatim}
    isSubset :: [TEntry] -> [TEntry] -> Bool
    isSubset _ []                               = True
    isSubset [] _                               = False
    isSubset ((l1, s1) : xs) ((l2, s2) : ys) 
        | l1 == l2    = s1 `isSubtype` s2 && xs `isSubset` ys
        | otherwise   = xs `isSubset` ((l2, s2) : ys)
\end{Verbatim}

Sorted fields are then checked for subtyping using the function \texttt{isSubset}. There are two cases when comparing two labels, each 
in a different record type: (1) if they are equal, then we have found the matched fields and need to check if one is a subtype of 
the other; (2) otherwise, we shift the longer record list over by one field and recursively check if the next field matches with the 
current field of the shorter record list.

\subsubsection{Evaluator}

Once an expression is typechecked successfully, it gets evaluated in accordance with the evaluation rules listed in section 2.4. 
Again, the single-step evaluation function \texttt{evaluate'} uses \texttt{Maybe Term} monad as the return type. We have seen 
the usage of monads before in the implementation of a typechecker. \texttt{Either TypeError Type} monad was used instead because it allows us 
to specify an optional return type, which in turn allows for more descriptive type errors. On the other hand, evaluation either 
succeeds or fails when a term gets stuck. We do not need to know specifically why a term cannot be evaluated. \texttt{Maybe Term} 
monad is a more suitable option because the return value may be another valid term, or \texttt{Nothing}, one single value that 
represents stuckness.

\begin{Verbatim}
    evaluate' :: Term -> Maybe Term
    evaluate' t = case t of
        -- Arithmetic
        Pred Zero                           -> Just Zero                               
        Pred (Succ nv) | isNumeric nv       -> Just nv                                  
        IsZero Zero                         -> Just Tru                                 
        IsZero (Succ nv) | isNumeric nv     -> Just Fls                                 
        IsZero t1                           -> IsZero <$> evaluate' t1                  
        Succ t1                             -> Succ <$> evaluate' t1                    
        Pred t1                             -> Pred <$> evaluate' t1                    

        -- Conditional
        If Tru t2 t3                        -> Just t2                                  
        If Fls t2 t3                        -> Just t3                                  
        If t1 t2 t3                         -> (\t1' -> If t1' t2 t3) 
                                               <$> evaluate' t1  

        -- Records
        Proj t l | isVal t                  -> getVal (Rec ls) l                        
        Proj t l                            -> (`Proj` l) <$> evaluate' t       
        Rec ls | not (isVal (Rec ls))       -> evalRecord t 

        -- Application
        App (Lambda _ t1 _) v2 | isVal v2   -> Just $ subsFromTop v2 t1                 
        App v1 t2 | isVal v1                -> App v1 <$> evaluate' t2                  
        App t1 t2                           -> (`App` t2) <$> evaluate' t1                                         
                        
        -- No rules applied
        _                                   -> Nothing  
\end{Verbatim}

The auxiliary function \texttt{isVal} checks if a term is a a constant, a number, a $\lambda$-abstraction, or a record of all values.

\begin{Verbatim}
    isVal :: Term -> Bool
    isVal t = case t of 
      Unit                  -> True
      Tru                   -> True
      Fls                   -> True
      t' | isNumeric t'     -> True
      Lambda {}             -> True
      Rec ls                -> areAllVal ls
      _                     -> False
\end{Verbatim}

Other two subroutines that are necessary to perform beta-reduction (\texttt{T-APPABS}) are \texttt{shift} for renumbering variables, and 
\texttt{subs} for replacing all the occurences of bound variables with a specified argument. These functions are transliterated from 
their formal definitions described in section 3.3. $\uparrow _c^d(t)$ is represented as \texttt{shift c d t}; and  
$[j \rightarrow s]t$ is represented as \texttt{subs j s t}.

\begin{Verbatim}
    shift :: Int -> Int -> Term -> Term
    shift c d t = case t of 
      Var k ty id      -> if k < c then t else Var (k + d) ty id
      Lambda ty t1 ctx -> Lambda ty (shift (c + 1) d t1) ctx 
      App t1 t2        -> App (shift c d t1) (shift c d t2)
      _                -> t 
      
    subs :: Int -> Term -> Term -> Term 
    subs j s t = case t of 
      Var k ty id      -> if k == j then s else t
      Lambda ty t1 ctx -> Lambda ty (subs (j + 1) (shift 0 1 s) t1) ctx
      App t1 t2        -> App (subs j s t1) (subs j s t2)
      _                -> t 
\end{Verbatim}

In order to carry out substitution $[j \rightarrow s]t$, we first shift the term being substituted $s$ for 
the bound variable up by 1 and shift everything down by 1 after There beta-reduction, because the bound variable has been replaced. 

\begin{Verbatim}
    subsFromTop :: Term -> Term -> Term
    subsFromTop s t = shift 0 (-1) (subs 0 (shift 0 1 s) t)
\end{Verbatim}

The big step evaluation routine \texttt{evaluateToValue} repeatedly calls \texttt{evaluate'} on a term until it reaches a value or gets stuck. 
The function \texttt{fromMaybe} takes a default value and a \texttt{Maybe} value, returning the former when the latter is \texttt{Nothing}. 
If a term is a value or stuck, evaluating it one step further would yield \texttt{Nothing}; thus the function \texttt{evaluateToValue} 
will terminate and return the term itself as the final output. 

\begin{Verbatim}
    evaluateToValue :: Term -> Term
    evaluateToValue x = fromMaybe x (evaluateToValue <$> evaluate' x)
\end{Verbatim}

\subsection{Prettier}

The library \texttt{PrettyPrint} [6] is used to implement a printer, which converts expressions from their AST representations to 
user-readable formats. We need to print terms, types, and type errors, and so create three instances of printers, all derived from 
the base class \texttt{Pretty}. 

\begin{Verbatim}
    class Pretty a where 
        output :: a -> Doc

        printPretty :: a -> String
        printPretty = PP.render . output
\end{Verbatim}

Class \texttt{Pretty} specifies two functions \texttt{output} and \texttt{printPretty}. \texttt{output} converts a type $a$ to a 
\texttt{Doc}, which is a set of layouts. This function is left as abstract because each  \texttt{Pretty} instance  
requires different formatting styles depending on its type. \texttt{printPretty} has a default implementation of 
piping the result of \texttt{output} to \texttt{PP.render} in order to print a type $a$ as a string. This function is shared by all 
the \texttt{Pretty} instances. 

\section{Interpreter} 

Now that we have created a lexer, a parser, a typechecker, an evaluator, and a prettier, our interpreter for the lambda 
calculus works as follows:

\begin{Verbatim}
    interpret :: String -> IO ()
    interpret line = case parseExpr line of 
        Right validExpr -> case typeOf validExpr of 
                            Right _  -> case evaluate validExpr of 
                                            Just res -> putStrLn $ printPretty res
                                            Nothing  -> putStrLn "Cannot evaluate"
                            Left err -> putStrLn $ printPretty err
        Left err        -> print err                    
\end{Verbatim}

The intepreter first parses the input stream as abstract syntax trees. If parsing succeeds, then the parsed expression is typechecked; otherwise, 
a parsing error is outputed. A well-typed expression is subsequently evaluated to a value, or a type error is raised. If the evaluation 
gets stuck, then we throw a \say{Cannot evaluate} error.

\section{Conclusion}

We have implemented an interpreter for the simply typed lambda calculus by building five key components: (1) a lexer to tokenize the 
user input stream, (2) a parser to represent terms as abtract syntax trees, (3) a typechecker to ensure a program is well-typed, (4) an 
evaluator to evaluate a well-typed term to a value, and (5) a pretty printer to output the evaluation result back to the user. Our 
Haskell intepreter is modelled after the OCaml implementation in the textbook, with the use of de Bruijn indices to represent variables 
and to avoid the issue of variable capture. The typechecking and evaluation procedures are transliterated directly from the formal 
definitions of the lambda calculus. One exception is the elimination of a global typing environment $\Gamma$ for typechecking variables; 
instead, each variable is responsible for maintaining its own type. Also, value \texttt{unit} and its type \texttt{Unit} are used 
as identity elements for parsing facilities rather than as a valid term and type option for the user. 

The most challenging aspect of this project is probably the implementation of a parser. Mutual recursion between different parser 
definitions could easily become complicated, and is difficult for debugging. In addition, our parser restricts the syntatical 
representation of arithmetic expressions and a projection. Accordingly, \texttt{succ t}, \texttt{pred t}, and \texttt{iszero t} can only 
be parsed if their argument \texttt{t} is a number; on the other hand, parsing a projection \texttt{Proj Term String} only succeeds if the
term \texttt{t} is a record. Such parsing restriction eliminates terms that might be semantically meaningless, thus minimizing the number of type  
errors [3]. Nonetheless, this restriction also eliminates terms that might be well-typed. For instance, \texttt{succ (if true then 0 else succ 0)} 
might look senseless at first glance, but is well-typed after \texttt{if true then 0 else succ 0} is evaluated to a number. Our parser, 
however, rejects this term as a syntax error. One of the future improvements would be to take away this parsing restriction for a 
more expressive language. 

This project has allowed me to have a better and deeper understanding of interpreting a language, starting from comprehending a 
source program to producing the final computational result. At the same time, learning to use advanced features of Haskell such as 
monads and pattern matching made me realize the elegance and intuitiveness of the language. I hope to continue building on top of  
this project and further extending the lambda calculus with other type systems that we covered in class.

\begin{thebibliography}{9}
    \bibitem{pierce} 
    Benjamin C. Pierce. 
    \textit{Types and Programming Languages}. 
    The MIT Press, Cambridge, 2002.
     
    \bibitem{haskell} 
    Graham Hutton. 
    \textit{Programming in Haskell}. 
    University Press, Cambridge, 2007.
     
    \bibitem{parsec} 
    S. Diehl:  Parsing,
    \\\texttt{http://dev.stephendiehl.com/fun/002\char`_parsers.html}

    \bibitem{parsec} 
    Haskell: Parsing a Simple Imperative Language,
    \\\texttt{https://wiki.haskell.org/Parsing\char`_a\char`_simple\char`_imperative\char`_language}

    \bibitem{parsec} 
    Parsec,
    \\\texttt{https://hackage.haskell.org/package/parsec}

    \bibitem{prettyprint} 
    PrettyPrint,
    \\\texttt{https://hackage.haskell.org/package/pretty-1.1.3.5/docs/Text-PrettyPrint.html}

    \bibitem{haskellsetup} 
    M. Doig: Setting up Haskell in VS Code on macOS,
    \\\texttt{https://medium.com/@dogwith1eye/setting-up-haskell-in-vs-code-on-macos-d2cc1ce9f60a}

    \bibitem{source} 
    Source code,
    \\\texttt{https://github.com/thuytien140894/Simply-Typed-Lambda-Calculus/tree/subtyping}
\end{thebibliography}

\end{document}