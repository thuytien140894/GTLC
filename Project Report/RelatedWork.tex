We have mentioned two 
strategies of blame tracking, which are UD and D. We 
prefer the UD variant for our interpreter because it works 
naturally with the coercion calculus defined in Herman et al. [4]. 
Siek et al. [8] introduce a mechanism to perform the D blame 
tracking for the coercion calculus that respects the traditional 
subtype relation. In this case, ? 
is the top element, and any upcast to ? is considered safe. 
As a result, their gradual system allows direct 
coercion between function types and dynamic types ? without the 
intermediate function dynamic types $? \rightarrow \: ?$. This feature 
enriches the semantics with higher-order projections and 
injections.

Henglein's coercion calculus [3] is originially adopted for the 
interpretation of the dynamically-typed $\lambda$-calculus. 
Whereas our source language is essentially the 
simply-typed $\lambda$-calculus with optional type annotations, 
Henglein's system works with the untyped variant where 
all terms are dynamically-typed. Hence, coercions are used 
primarily for tagging inputs of primitive operators, whose 
types are fixed. Henglein also makes use of function tags 
$\texttt{Fun}!$ and $\texttt{Fun}?$ to differentiate between 
general dynamic types and function dynamic types.

Some languages that support gradual typing are TypeScript and 
C\#. TypeScript allows the programmer to opt out of typechecking 
during compilation by labeling variables that may have dynamic 
content as \texttt{any}. Variables with no type annotations 
default to the \texttt{any} type as well. Similarly, C\# provides
the \texttt{dynamic} annotation to mark variables as dynamically-typed. 


